use std::time;
use std::time::Duration;
use std::vec;

use log::info;
use prost::Message;
use proxy_wasm::traits::*;
use proxy_wasm::types::*;

proxy_wasm::main! {{
    proxy_wasm::set_log_level(LogLevel::Debug);
    proxy_wasm::set_http_context(|_,_| -> Box<dyn HttpContext> { Box::new(HttpCall)});
}}

/// original protobuf generated by build.rs
// #[derive(Clone, PartialEq, ::prost::Message)]
// pub struct HelloRequest {
//     #[prost(string, tag = "1")]
//     pub name: ::prost::alloc::string::String,
//     #[prost(string, tag = "2")]
//     pub message: ::prost::alloc::string::String,
// }

#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HelloRequest {
    #[prost(string, tag = "1")]
    pub name: String,
    #[prost(string, tag = "2")]
    pub message: String,
}

struct HttpCall;
impl HttpContext for HttpCall {
    fn on_http_request_headers(&mut self, _num_headers: usize, _end_of_stream: bool) -> Action {

        let msg = HelloRequest {
            name: "wasm".to_string(),
            message: "hello".to_string(),
        };

        match self.get_http_request_header(":path") {

            Some(route) if route.starts_with("/go") => {
                let res = self.dispatch_grpc_call(
                    "grpc_go_cluster",
                    "HelloService",
                    "SayHello",
                    vec![],
                    Some(msg.encode_to_vec().as_slice()),
                    Duration::from_secs(2),
                );
                match res {
                    Ok(o) => info!("go_get response: {:?}", o),
                    Err(e) => info!("go_got error: {:?}", e),
                }
            } 

            Some(path) if path == "/uuid" => {
                match self.dispatch_http_call(
                    "https_httpbin_org",
                    vec![
                        (":method", "GET"),
                        (":path", "/uuid"),
                        (":authority", "httpbin.org"),
                        ("Content-Type", "application/x-www-form-urlencoded"),
                    ],
                    None,
                    vec![],
                    time::Duration::from_secs(10),
                ) {
                    Ok(o) => info!("get ok, uuid = {}", o),
                    Err(e) => info!("get err, {:?}", e),
                }
            }

            _ => {
                let res = self.dispatch_grpc_call(
                    "grpc_rs_cluster",
                    "hello.HelloService",
                    "SayHello",
                    vec![],
                    Some(msg.encode_to_vec().as_slice()),
                    Duration::from_secs(2),
                );
                match res {
                    Ok(o) => info!("rs_got response: {:?}", o),
                    Err(e) => info!("rs_got error: {:?}", e),
                }
            }
        }

        Action::Pause
    }
}

impl Context for HttpCall {
    fn on_http_call_response(
        &mut self,
        token_id: u32,
        _num_headers: usize,
        body_size: usize,
        _num_trailers: usize,
    ) {
        let body = self.get_http_call_response_body(0, body_size);
        match body {
            Some(b) => info!(
                "token_id {} call response body = {}",
                token_id,
                String::from_utf8(b).unwrap()
            ),
            _ => info!("token_id {} call response none", token_id),
        }

        self.resume_http_request();
    }
    fn on_grpc_call_response(&mut self, _token_id: u32, status_code: u32, _response_size: usize) {
        if status_code % 2 == 0 {
            info!("got status_code: {:?}, ", status_code);
            self.resume_http_request();
        } else {
            info!("got error code: {:?}", status_code);
            self.send_grpc_response(
                GrpcStatusCode::Aborted,
                Some("Aborted by Proxy-Wasm!"),
                vec![("Power-by", b"proxy-wasm")],
            );
        }
    }

}
